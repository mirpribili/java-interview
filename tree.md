\[to c \]
\[toc]

[toc]

* * *

☂ Тема  
├── вариант 1  
│ └── вариант 2  
│ └── вариант 3  
└── вариант 4

* * *

## equals Contract ☂
├── Reflexivity - Для любого ненулевого референса x: x.equals(x) должно вернуть true.  
│  
├── Symmetry - Для любых ненулевых референсов x и y: если x.equals(y) возвращает true, то y.equals(x)  
│ должно также возвращать true.  
│  
├── Transitivity - Для любых ненулевых референсов x, y и z: если x.equals(y) возвращает true, и 
│ y.equals(z) возвращает true, то x.equals(z) должно возвращать true.  
│  
└── Consistency - Для любых ненулевых референсов x и y: многократные вызовы x.equals(y) должны  
возвращать одно и то же значение, пока информация, используемая в equals, не изменится.

* * *

## PostgreSQL Indexes ☂
├── Definition - Структура, позволяющая быстро извлекать строки из таблицы.  
│  
├── Types of Indexes  
│ ├── B-Tree Index -  
│ │ ├── По умолчанию создается при выполнении команды CREATE INDEX.  
│ │ ├── Подходит для равенства и диапазонных запросов.  
│ │ └── Эффективен для всех типов данных и NULL значений.  
│ │  
│ ├── Hash Index -  
│ │ ├── Используется только для равенства.  
│ │ ├── Не рекомендуется до PostgreSQL 10 из-за проблем с безопасностью транзакций.  
│ │ └── С версии 10 поддерживает журналирование WAL и репликацию.  
│ │  
│ ├── GiST Index -  
│ │ ├── Позволяет строить общие сбалансированные деревья.  
│ │ ├── Используется для индексирования геометрических типов данных и  
│ │ │ полнотекстового поиска.  
│ │ └── Поддерживает различные стратегии индексации.  
│ │  
│ ├── GIN Index -  
│ │ ├── Подходит для индексации массивов и значений с множественными компонентами.  
│ │ └── Используется для полнотекстового поиска.  
│ │  
│ ├── SP-GiST Index -  
│ │ ├── Поддерживает различные структуры данных, такие как квадродеревья.  
│ │ └── Используется для реализации специфических поисковых алгоритмов.  
│ │  
│ ├── BRIN Index -  
│ │ ├── Подходит для больших таблиц с последовательными данными.  
│ │ └── Эффективен для минимизации объема памяти.  
│ │  
│ └── Unique Index -  
│ ├── Гарантирует уникальность значений в столбце.  
│ └── Улучшает целостность данных и производительность запросов.  
│  
└── Expression Indexes -  
├── Индексирует результат функции или модификации данных.  
└── Используется для оптимизации запросов с функциями, например, `lower(email)`.

* * *
## ☂ Стратегии задания идентификаторов в PostgreSQL
├── SERIAL
│   ├── Описание: 
│   │   Автоинкрементный 
│   └── Преимущества:
│       Удобство использования, автоматическое управление значениями, простота в реализации.
├── BIGSERIAL
│   └── Преимущества:
│       Подходит для таблиц с большим количеством записей.
├── UUID
│   └── Преимущества:
│       Глобальная уникальность, подходит для распределённых систем.
├── IDENTITY
|  └── Улучшенная атомарность: Хотя IDENTITY также использует последовательности под капотом, он предоставляет более строгие гарантии, что значения будут уникальными и не будут пересекаться в многопоточных сценариях.
└── Явное указание ID
	
* * *

## Transaction Isolation Levels
├── READ_UNCOMMITTED - Чтение незафиксированных  
│ данных (грязные чтения возможны)  
│  
├── READ_COMMITTED - Чтение только  
│ зафиксированных данных (предотвращает  
│ грязные чтения), но остаются  
│ неповторяемые чтения имеющихся строк  
│  
├── REPEATABLE_READ - Повторяемое чтение  
│ (предотвращает грязные и  
│ неповторяемые чтения), но  
│ "фантомное чтение новых строк"  
│ **\+ в PostgreSQL также защищена  
│ от фантомного чтения через снимки**  
│  
└── SERIALIZABLE - Сериализуемый уровень  
(самый строгий, предотвращает все  
аномалии)

* * *

## CompletableFuture Methods
├── get() - Блокирующий, возвращает  
│ результат  
│  
├── join() - Блокирующий, возвращает  
│ результат или выбрасывает  
│ исключение  
│  
├── complete(T) - Завершает бин с 
│ указанным значением  
│  
├── completeExceptionally(Throwable) -  
│ Завершает бин с исключением  
│  
├── whenComplete(BiConsumer) -  
│ Обрабатывает завершение,  
│ независимо от результата  
│  
├── exceptionally(Function) -  
│ Обрабатывает исключение и  
│ возвращает значение  
│  
├── handle(BiFunction) -  
│ Обрабатывает результат или  
│ исключение  
│  
├── thenApply(Function) -  
│ Применяет функцию к результату 
│  
├── thenAccept(Consumer) -  
│ Выполняет действие с результатом  
│  
└── thenRun(Runnable) -  
Выполняет действие после  
завершения

* * *

## Bean Scopes
├── Singleton - Один экземпляр бина на весь контейнер  
├── Prototype - Новый экземпляр создается при каждом запросе  
├── Request - Экземпляр бина для каждого HTTP-запроса  
├── Session - Экземпляр бина для каждой HTTP-сессии  
└── Global Session - Экземпляр бина для глобальной HTTP-сессии (для портлетов)

* * *

## Bean Annotations
├── @Component - Общая аннотация для определения бина  
├── @Service - Специальная аннотация для сервисных компонентов  
├── @Repository - Аннотация для DAO-компонентов, обрабатывающих исключения  
├── @Controller - Аннотация для контроллеров в веб-приложениях  
├── @Configuration - Аннотация для классов, содержащих конфигурацию бинов  
└── @Bean - Аннотация для определения метода, возвращающего бин

* * *

## Transaction Annotations
├── @Transactional - Обозначает метод или класс как транзакционный. Это значит, что все операции внутри этого метода будут выполняться в рамках одной транзакции.  
│ └── @Transactional(propagation = Propagation) - Указывает тип поведения транзакции.  
│ ├── Propagation.REQUIRED - Если существует активная транзакция, метод будет участвовать в ней. Если транзакции нет, будет создана новая. Это наиболее часто используемый режим.  
│ ├── Propagation.REQUIRES_NEW - Всегда создает новую транзакцию. Если текущая транзакция существует, она будет приостановлена до завершения новой транзакции.  
│ ├── Propagation.SUPPORTS - Участвует в транзакции, если она активна. Если транзакции нет, метод будет выполнен без транзакции.  
│ ├── Propagation.NOT_SUPPORTED - Метод не участвует в транзакциях. Если существует активная транзакция, она будет приостановлена.  
│ ├── Propagation.NEVER - Метод не должен участвовать в транзакциях. Если активная транзакция существует, будет выброшено исключение.  
│ ├── Propagation.MANDATORY - Метод должен участвовать в существующей транзакции. Если транзакции нет, будет выброшено исключение.  
│ └── Propagation.NESTED - Позволяет создавать вложенные транзакции. Если существует активная транзакция, будет создана новая вложенная транзакция. Если вложенная транзакция завершится неудачно, изменения будут отменены, но основная транзакция продолжит свою работу.  
│  
├── @EnableTransactionManagement - Включает поддержку управления транзакциями в конфигурации приложения.  
│ └── mode = AdviceMode.PROXY - Использует режим проксирования для управления транзакциями, позволяя создавать прокси-объекты для методов с аннотацией @Transactional.  
│ └── mode = AdviceMode.ASPECTJ - Использует режим AspectJ для управления транзакциями, позволяя более гибкое управление аспектами без создания прокси.  
│  
├── @Transactional(isolation = Isolation) - Указывает уровень изоляции транзакции, который определяет, как изменения в одной транзакции видны другим транзакциям.  
│ ├── Isolation.DEFAULT - Использует настройки источника данных по умолчанию.  
│ ├── Isolation.READ_UNCOMMITTED - Позволяет чтение незафиксированных данных (грязные чтения возможны).  
│ ├── Isolation.READ_COMMITTED - Позволяет чтение только зафиксированных данных, предотвращая грязные чтения, но оставляя возможность неповторяемых чтений.  
│ ├── Isolation.REPEATABLE_READ - Предотвращает грязные и неповторяемые чтения, но может возникать "фантомное чтение" новых строк.  
│ └── Isolation.SERIALIZABLE - Самый строгий уровень изоляции, предотвращающий все аномалии, включая фантомные чтения.  
│  
└── @Transactional(timeout = seconds) - Указывает тайм-аут транзакции в секундах. Если транзакция не завершится в указанный срок, она будет автоматически отменена.

* * *

## Java Collections
├── Collection - Корневой интерфейс для всех коллекций  
│ ├── List - Упорядоченная коллекция, допускающая дубликаты  
│ │ ├── ArrayList - Реализация списка на основе массива  
│ │ ├── LinkedList - Реализация списка на основе связного списка  
│ │ └── Vector - Устаревшая реализация списка, синхронизированная  
│ ├── Set - Коллекция, не допускающая дубликаты  
│ │ ├── HashSet - Реализация множества на основе хеш-таблицы 
│ │ ├── LinkedHashSet - Хранит порядок вставки элементов  
│ │ └── TreeSet - Реализация множества, хранящая элементы в отсортированном порядке  
│ └── Queue - Коллекция для хранения элементов в порядке их обработки  
│ ├── PriorityQueue - Очередь, упорядоченная по приоритету  
│ └── LinkedList - Может использоваться как очередь  
└── Map - Коллекция пар "ключ-значение"  
├── HashMap - Реализация карты на основе хеш-таблицы  
├── LinkedHashMap - Хранит порядок вставки ключей  
└── TreeMap - Реализация карты, хранящая ключи в отсортированном порядке

* * *

## Concurrent Collections
├── java.util.concurrent - Пакет для потокобезопасных коллекций  
│ ├── ConcurrentHashMap - реализация интерфейса Map  
│ ├── CopyOnWriteArrayList - Создает копии при изменениях  
│ ├── BlockingQueue - Интерфейс для очередей с блокировкой  
│ │ ├── LinkedBlockingQueue - Реализация на основе связного списка  
│ │ ├── ArrayBlockingQueue - Ограниченная очередь на основе массива  
│ │ └── PriorityBlockingQueue - С приоритетом  
│ ├── ConcurrentLinkedQueue - Неблокирующая очередь  
│ ├── ConcurrentSkipListMap - отсортированная карта  
│ └── ConcurrentSkipListSet - отсортированное множество

* * *

## Design Patterns
├── Creational Patterns  
│ ├── Singleton - Обеспечивает создание единственного экземпляра класса  
│ ├── Factory Method - Определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемого объекта  
│ ├── Abstract Factory - Интерфейс для создания семейств связанных объектов без указания их конкретных классов  
│ ├── Builder - Позволяет создавать сложные объекты пошагово  
│ └── Prototype - Создает новые объекты путем копирования существующих  
│  
├── Structural Patterns  
│ ├── Adapter - Позволяет несовместимым интерфейсам работать вместе  
│ ├── Bridge - Разделяет абстракцию и реализацию, позволяя изменять их независимо  
│ ├── Composite - Позволяет объединять объекты в древовидные структуры для представления иерархий  
│ ├── Decorator - Добавляет новые функциональные возможности к объектам динамически  
│ ├── Facade - Предоставляет упрощенный интерфейс к сложной системе  
│ ├── Flyweight - Оптимизирует использование памяти, разделяя общие состояния объектов  
│ └── Proxy - Предоставляет суррогат или заместитель для другого объекта для контроля доступа  
│  
└── Behavioral Patterns  
├── Chain of Responsibility - Позволяет передавать запросы по цепочке обработчиков  
├── Command - Инкапсулирует запрос как объект, позволяя параметризовать клиентов  
├── Interpreter - Определяет грамматику и интерпретирует предложения в языке  
├── Iterator - Предоставляет способ последовательного доступа к элементам коллекции  
├── Mediator - Обеспечивает взаимодействие между объектами, уменьшая их связанность  
├── Memento - Позволяет сохранять и восстанавливать состояние объекта  
├── Observer - Определяет зависимость "один ко многим" между объектами  
├── State - Позволяет объекту изменять свое поведение при изменении его состояния  
├── Strategy - Определяет семейство алгоритмов и делает их взаимозаменяемыми  
└── Template Method - Определяет основу алгоритма, позволяя подклассам изменять некоторые шаги

* * *

## Stream API
├── Создание потоков  
│ ├── Stream.of() - Создание потока из заданных значений.  
│ ├── Collection.stream() - Создание потока из коллекции.  
│ ├── Arrays.stream() - Создание потока из массива.  
│ └── Stream.generate() - Создание бесконечного потока значений на основе заданного генератора.  
│  
├── Промежуточные операции  
│ ├── filter() - Фильтрация элементов по заданному предикату.  
│ ├── map() - Преобразование элементов потока с помощью заданной функции.  
│ ├── flatMap() - Преобразование элементов потока, возвращающих другие потоки, и объединение их в один поток.  
│ ├── distinct() - Удаление дубликатов из потока.  
│ ├── sorted() - Сортировка элементов потока.  
│ └── peek() - Применение функции к каждому элементу потока без изменения потока.  
│  
├── Заключительные операции  
│ ├── forEach() - Применение действия к каждому элементу потока.  
│ ├── collect() - Сбор элементов потока в коллекцию или другую структуру данных.  
│ │ ├── Collectors.toList() - Преобразование потока в список.  
│ │ ├── Collectors.toSet() - Преобразование потока в множество.  
│ │ ├── Collectors.toMap() - Преобразование потока в карту (Map).  
│ │ └── Collectors.joining() - Объединение элементов потока в строку.  
│ ├── reduce() - Сведение элементов потока к одному значению с помощью заданной бинарной операции.  
│ ├── count() - Подсчет количества элементов в потоке.  
│ └── findFirst() - Получение первого элемента потока.  
│  
├── Параллельные потоки  
│ ├── parallelStream() - Создание параллельного потока из коллекции.  
│ ├── parallel() - Преобразование последовательного потока в параллельный.  
│ └── sequential() - Преобразование параллельного потока в последовательный.  
│  
└── Обработка исключений  
├── try-catch в промежуточных операциях - Обработка исключений во время обработки элементов.  
└── onError() - Обработка ошибок в потоках (в контексте реактивного программирования).

* * *

## Flux и Mono Publishers из спецификации Reactive Streams:
Flux и Mono  
├── Flux - Представляет собой поток данных, который может испускать от 0 до N элементов. Используется для работы с последовательностями данных.  
│ ├── Flux.just(...) - Создает Flux из заданных значений.  
│ ├── filter(...) - Применяет фильтр к элементам потока, пропуская только те, которые соответствуют условию.  
│ ├── map(...) - Преобразует элементы потока, применяя заданную функцию к каждому элементу.  
│ ├── subscribe(...) - Подписывается на поток данных и определяет, что делать с каждым элементом.  
│ └── onErrorReturn(...) - Обрабатывает ошибки, возвращая запасное значение при возникновении исключения.  
│  
├── Mono - Представляет собой поток данных, который может испускать 0 или 1 элемент. Используется для работы с единичными значениями.  
│ ├── Mono.just(...) - Создает Mono из заданного значения.  
│ ├── map(...) - Преобразует значение Mono, применяя заданную функцию.  
│ ├── doOnNext(...) - Выполняет действие при наличии значения, не изменяя его.  
│ ├── subscribe(...) - Подписывается на Mono и определяет, что делать с полученным значением.  
│ └── onErrorResume(...) - Обрабатывает ошибки, предоставляя альтернативный поток данных в случае исключения.  
│  
└── Общие операторы - Flux и Mono предоставляют множество операторов для манипуляции и обработки данных, включая:  
├── flatMap(...) - Преобразует элементы в другие потоки и объединяет их.  
├── concatWith(...) - Объединяет два потока, испуская элементы последовательно.  
├── collectList() - Собирает элементы потока в список.  
└── repeat(...) - Повторяет поток данных заданное количество раз или до определенного условия.  
...  
Если вы просто хотите дождаться завершения всех операций, blockLast() или collectList().block()

* * *

## Блокировки
├── Пессимистичные блокировки  
│ ├── Блокировка на чтение (Shared Lock)  
│ │ ├── Предотвращает запись других транзакций  
│ │ └── Разрешает чтение другими транзакциями  
│ │ ├── Используется в БД  
│ │ │ ├── SELECT ... FOR SHARE 
│ │ │ └── SELECT ... FOR UPDATE  
│ │ └── Используется в приложениях редко  
│ └── Блокировка на запись (Exclusive Lock)  
│ ├── Предотвращает чтение и запись других транзакций  
│ └── Разрешает чтение и запись только владельцу блокировки  
│ ├── Используется в БД  
│ │ └── UPDATE, DELETE, INSERT  
│ └── Используется в приложениях редко  
│  
└── Оптимистичные блокировки  
├── Версионирование (Optimistic Locking)  
│ ├── Каждая запись имеет версию  
│ ├── При обновлении проверяется версия  
│ └── Если версия изменилась, обновление отклоняется  
│ ├── Используется в БД редко  
│ └── Используется в приложениях  
│ ├── @Version в JPA  
│ └── optimisticLock в Spring Data  
└── Временные метки (Timestamp Locking)  
├── Каждая запись имеет временную метку  
├── При обновлении проверяется временная метка  
└── Если метка изменилась, обновление отклоняется  
├── Используется в БД редко  
└── Используется в приложениях  
└── optimisticLock в Spring Data

* * *

## Блокировки в Spring и JDBC
├── Пессимистичные блокировки  
│ ├── В JDBC  
│ │ ├── SELECT ... FOR UPDATE  
│ │ └── SELECT ... FOR SHARE  
│ └── В Spring  
│ ├── @Lock(LockModeType.PESSIMISTIC_WRITE) в JPA  
│ └── @Lock(LockModeType.PESSIMISTIC_READ) в JPA  
│  
└── Оптимистичные блокировки  
├── В JDBC  
│ ├── Версионирование  
│ │ ├── Добавление версионной колонки в таблицу  
│ │ └── Проверка версии при обновлении  
│ └── Временные метки  
│ ├── Добавление колонки с временной меткой в таблицу  
│ └── Проверка метки при обновлении  
└── В Spring  
├── @Version в JPA  
├── @Lock(LockModeType.OPTIMISTIC) в JPA  
├── @Lock(LockModeType.OPTIMISTIC_FORCE_INCREMENT) в JPA  
└── optimisticLock() в Spring Data

* * *

## Locking Strategies
├── Optimistic Locking - Предполагает редкие конфликты, блокировки не накладываются до сохранения изменений.  
│ ├── Применение: Используется в сценариях с высокой степенью параллелизма.  
│ ├── Реализация: Проверка версии данных перед записью (например, с помощью аннотации @Version в JPA).  
│ └── Результат: Если данные были изменены другой транзакцией, операция завершится с ошибкой, и транзакцию можно повторить.  
│  
└── Pessimistic Locking - Предполагает частые конфликты, блокировки накладываются сразу при доступе к данным.  
├── Применение: Используется в сценариях с высокой вероятностью конфликтов.  
├── Реализация: Блокировка удерживается до завершения транзакции (например, с помощью @Lock в JPA).  
└── Результат: Гарантирует эксклюзивный доступ к данным, предотвращая изменения другими транзакциями.

* * *

## HTTP Request Structure
├── Start Line - Стартовая строка запроса, содержащая три основных компонента:  
│ ├── Method - Метод HTTP (например, GET, POST, PUT, DELETE), указывающий действие, которое необходимо выполнить.  
│ ├── Request-URI - URI ресурса, к которому осуществляется запрос (например, /api/users).  
│ └── HTTP Version - Версия протокола HTTP (например, HTTP/1.1).  
│  
├── Headers - Заголовки запроса, содержащие метаданные о запросе:  
│ ├── Host - Указывает домен сервера, к которому осуществляется запрос.  
│ ├── User-Agent - Идентифицирует клиентское приложение (браузер) и его версию.  
│ ├── Accept - Определяет типы медиа, которые клиент может принимать (например, application/json).  
│ ├── Content-Type - Указывает тип содержимого в теле запроса (например, application/json).  
│ └── Другие заголовки, которые могут быть специфичными для приложения или протокола.  
│  
├── Blank Line - Пустая строка, отделяющая заголовки от тела запроса.  
│  
└── Body - Тело запроса (необязательная часть), содержащее данные, которые отправляются на сервер (например, JSON-объект при POST-запросе).

* * *

POST /api/users HTTP/1.1  
Host: example.com  
Content-Type: application/json  
Accept: application/json

{  
"name": "John Doe",  
"email": "john.doe@example.com"  
}

* * *

## Multithreading Concepts
├── Threads - Основные единицы выполнения в Java.  
│ ├── Thread Class - Класс для создания и управления потоками.  
│ ├── Runnable Interface - Интерфейс для определения задачи, выполняемой в потоке.  
│ └── Thread Lifecycle - Жизненный цикл потока:  
│ ├── New - Новый поток.  
│ ├── Runnable - Поток готов к выполнению.  
│ ├── Blocked - Поток заблокирован.  
│ ├── Waiting - Поток ожидает.  
│ └── Terminated - Поток завершен.  
│  
├── Synchronization - Механизмы синхронизации для управления доступом к ресурсам.  
│ ├── Synchronized Blocks - Блоки кода, защищенные синхронизацией.  
│ ├── Locks - Более гибкие механизмы синхронизации.  
│ │ ├── ReentrantLock - Мьютекс, поддерживающий повторный захват.  
│ │ └── ReadWriteLock - Позволяет нескольким потокам читать, но блокирует запись.  
│ ├── Volatile Variables - Переменные, доступ к которым не кэшируется, обеспечивая видимость изменений.  
│ └── Atomic Variables - Переменные, которые обеспечивают атомарные операции.  
│  
├── Semaphores - Механизм синхронизации для управления доступом к ресурсам.  
│ ├── Definition - Семафор как счетчик, контролирующий количество потоков, имеющих доступ.  
│ ├── Counting Semaphore - Позволяет нескольким потокам одновременно получать доступ к ресурсу.  
│ └── Binary Semaphore - Позволяет только одному потоку получить доступ к ресурсу.  
│  
├── Condition Variables - Позволяют потокам ожидать определенных условий.  
│ ├── await() - Ожидание сигнала. 
│ └── signal() - Уведомление ожидающих потоков.  
│  
└── Thread Pools - Группы потоков для управления многопоточными задачами.  
├── Executor Framework - Интерфейс для управления потоками.  
├── Fixed Thread Pool - Фиксированное количество потоков.  
└── Cached Thread Pool - Динамическое создание потоков по мере необходимости.

* * *

## Happens-Before Principle
├── Definition - Определение порядка  
│ выполнения операций в многопоточном  
│ окружении.  
│  
├── Transitive Property -  
│ Если A happens-before B, и B  
│ happens-before C, то A  
│ happens-before C.  
│  
├── Program Order Rule -  
│ Каждая операция в одном потоке 
│ происходит в порядке, в котором 
│ они были написаны.  
│  
├── Monitor Lock Rule -  
│ Захват монитора (синхронизация)  
│ потоком A делает все операции  
│ этого потока видимыми для других  
│ потоков, которые захватывают тот  
│ же монитор.  
│  
├── Volatile Variable Rule -  
│ Запись в переменную с  
│ модификатором `volatile`  
│ происходит до всех последующих  
│ чтений этой переменной.  
│  
└── Thread Start/Join Rule -  
Запуск потока (start)  
происходит до завершения  
потока (join).

* * *

## Microservices Design Pattern
├── Scalability - Возможность  
│ горизонтального масштабирования сервисов для обработки  
│ увеличивающейся нагрузки.  
│  
├── Decoupling - Сервисы  
│ независимы друг от друга, что позволяет разрабатывать,  
│ тестировать и развертывать их отдельно.  
│  
├── API-First Approach -  
│ Проектирование API на начальном этапе, что  
│ упрощает интеграцию между сервисами.  
│  
├── Resilience - Использование  
│ паттернов, таких как Circuit Breaker и Retry,  
│ для повышения устойчивости системы к сбоям.  
│  
├── Continuous Deployment -  
│ Автоматизация процессов развертывания и тестирования,  
│ что позволяет быстро вносить изменения и обновления.  
│  
├── Service Orchestration -  
│ Управление взаимодействием между сервисами с помощью  
│ оркестраторов или сервисов управления.  
│  
├── Data Management -  
│ Использование подходов, таких как Database per Service,  
│ для управления данными, что обеспечивает независимость и изоляцию.  
│  
└── Monitoring and Observability -  
Внедрение систем мониторинга и логирования для отслеживания  
производительности, доступности и диагностики проблем.

* * *

## Microservices Architecture
├── Service Discovery - Механизм для обнаружения и взаимодействия между микросервисами.  
│  
├── API Gateway - Упрощает взаимодействие клиентов с микросервисами, обеспечивая единый  
│ входной пункт для запросов.  
│  
├── Load Balancing - Распределяет входящие запросы между экземплярами микросервисов для  
│ повышения доступности и производительности.  
│  
├── Circuit Breaker - Защищает систему от сбоя, предотвращая повторные запросы к  
│ неработающим сервисам.  
│  
├── Database per Service - Каждый микросервис имеет свою собственную базу данных, что  
│ обеспечивает независимость и изоляцию данных.  
│  
├── Event Sourcing - Хранит состояние приложения как последовательность событий, что позволяет  
│ восстанавливать состояние системы.  
│  
├── CQRS (Command Query Responsibility Segregation) - Разделяет операции чтения и записи для  
│ оптимизации производительности и масштабируемости.  
│  
└── Monitoring and Logging - Системы для отслеживания состояния микросервисов и анализа логов  
для диагностики и устранения проблем.

* * *

## ☂ Порядок выполнения SQL-запроса с блокировкой
├── 1. BEGIN  
│ └── Начинает транзакцию, что позволяет выполнять несколько операций в рамках одной транзакции.  
├── 2. FROM  
│ └── Определяет, из каких таблиц будут извлекаться данные (в данном случае, таблицы `employees` и `departments`). 
├── 3. JOIN  
│ └── Выполняет соединение таблиц `employees` и `departments` на основе условия `ON e.department_id = d.id`.  
├── 4. WHERE  
│ └── Применяет фильтрацию к результатам, оставляя только те записи, где `d.name = 'Sales'`. 
├── 5. FOR UPDATE SKIP LOCKED  
│ └── Блокирует выбранные строки для предотвращения изменений другими транзакциями, пропуская строки, которые  
 | уже заблокированы другими транзакциями.  
├── 6. SELECT  
│ └── Извлекает указанные столбцы (`e.name`, `e.salary`) из отфильтрованных данных.  
├── 7. ORDER BY  
│ └── Сортирует результаты по `e.salary` в порядке убывания (`DESC`).  
└── 8. LIMIT  
└── Ограничивает количество возвращаемых строк до 10.  
└── 9. COMMIT  
└── Завершает транзакцию, применяя все изменения и освобождая блокировки.

> 240815

* * *
### Сравнение уровней абстракции
- JDBC (низкий уровень)
- Spring JDBC
- MyBatis
- JPA
- Hibernate (как реализация JPA)
- HQL (как язык запросов в Hibernate)
- Criteria API
- Spring Data JPA (высокий уровень)
* * *
## ☂ Виды доступа к базе данных в Java
- **JDBC**: Базовый уровень, предоставляющий прямой доступ к базе данных.
- - *Statement*: Для выполнения простых SQL-запросов без параметров.
- - *PreparedStatement*: Для выполнения параметризованных SQL-запросов, что улучшает безопасность и производительность.
- - *CallableStatement*: Для вызова хранимых процедур в базе данных.
- **Spring JDBC**: Уровень, обеспечивающий удобные абстракции для работы с JDBC.
- - *JdbcTemplate*: Упрощает выполнение SQL-запросов и обработку результатов.
- - *NamedParameterJdbcTemplate*: Использует именованные параметры для более удобного управления параметрами.
- **Hibernate**: Уровень ORM, предоставляющий более высокий уровень абстракции для работы с базами данных.
- - *HQL*: Позволяет писать запросы, используя объектно-ориентированный подход.
- - *Criteria API*: Позволяет динамически создавать запросы программно.
- - *Native SQL*: Позволяет использовать обычные SQL-запросы, если другие методы не подходят.
JDBC, Spring JDBC, HQL
- **Spring Data**: Уровень, который упрощает работу с данными и предоставляет дополнительные абстракции для доступа к различным источникам данных.
  - *Spring Data JPA*: Обеспечивает интеграцию с JPA и Hibernate, позволяя использовать репозитории для работы с сущностями.
  - *Spring Data JDBC*: Предоставляет упрощенный способ работы с JDBC, без необходимости использования ORM.
  - *Spring Data MongoDB*: Обеспечивает поддержку для работы с MongoDB, используя репозитории.
  - *Spring Data Redis*: Предоставляет абстракции для работы с Redis.
  - *Spring Data REST*: Позволяет автоматически создавать RESTful API на основе Spring Data репозиториев.
* * *
## ☂ Виды осуществления запросов к БД в Java  
├── JDBC  
│ ├── Statement  
│ │ └── `Statement stmt = connection.createStatement();`  
│ ├── PreparedStatement  
│ │ └── `PreparedStatement pstmt = connection.prepareStatement("SELECT * FROM users WHERE id = ?");`  
│ └── CallableStatement  
│ └── `CallableStatement cstmt = connection.prepareCall("{call getUser(?)}");`  
├── Spring JDBC  
│ ├── JdbcTemplate  
│ │ └── `jdbcTemplate.query("SELECT * FROM users", new UserRowMapper());`  
│ └── NamedParameterJdbcTemplate  
│ └── `namedParameterJdbcTemplate.query("SELECT * FROM users WHERE id = :id", params, new UserRowMapper());`  
└── Hibernate  
   ├── HQL  
   │ └── `List<User> users = session.createQuery("FROM User", User.class).list();`  
   ├── Criteria API  
   │ └── `List<User> users = session.createCriteria(User.class).list();`  
   └── Native SQL  
   └── `List<User> users = session.createNativeQuery("SELECT * FROM users", User.class).getResultList();`
* * *
Теорема CAP
├── Согласованность (Consistency)
│ └── Все узлы системы возвращают одно и то же значение для одного и того же запроса, даже если запросы происходят одновременно.
├── Доступность (Availability)
│ └── Каждый запрос получает ответ, даже если некоторые узлы недоступны. Система всегда отвечает, но может вернуть устаревшие данные.
└── Устойчивость к разделению (Partition Tolerance)
     └── Система продолжает функционировать, даже если сеть разделена на части, и узлы не могут общаться друг с другом.

> 240816
* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *
1. Основы ООП
Инкапсуляция: Скрытие внутреннего состояния объекта и предоставление доступа к нему только через методы.
Наследование: Позволяет создавать новые классы на основе существующих, что способствует повторному использованию кода.
Полиморфизм: Возможность использовать один интерфейс для разных типов объектов, что позволяет вызывать методы, специфичные для конкретного класса.
2. Паттерны проектирования
Singleton: Обеспечивает создание единственного экземпляра класса и предоставляет глобальную точку доступа к нему.
Factory Method: Определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемого объекта.
Observer: Определяет зависимость "один ко многим" между объектами, так что при изменении состояния одного объекта все его зависимые объекты уведомляются и обновляются автоматически.
3. Работа с API
RESTful API: Принципы проектирования REST, включая методы HTTP (GET, POST, PUT, DELETE), статус-коды и структуру URL.
Swagger/OpenAPI: Инструменты для документирования и тестирования API.
4. Основы работы с базами данных
Нормализация: Процесс организации данных в базе данных для уменьшения избыточности и улучшения целостности данных.
Транзакции: Основные свойства ACID (Atomicity, Consistency, Isolation, Durability) и их значение для обеспечения надежности операций с данными.
5. Основы многопоточности
Потоки и задачи: Различие между потоками и задачами, создание и управление потоками.
Синхронизация: Использование synchronized, Locks, CountDownLatch, CyclicBarrier для управления доступом к общим ресурсам.
6. Основы тестирования
Юнит-тестирование: Принципы написания юнит-тестов с использованием JUnit и Mockito.
Интеграционное тестирование: Тестирование взаимодействия между компонентами системы.
7. Основы DevOps
CI/CD: Понимание концепций непрерывной интеграции и непрерывного развертывания, инструменты (Jenkins, GitLab CI, CircleCI).
Контейнеризация: Основы работы с Docker, создание и управление контейнерами.
8. Основы безопасности
Аутентификация и авторизация: Различие между аутентификацией (проверка личности) и авторизацией (проверка прав доступа).
Основные уязвимости: Знание о распространенных уязвимостях, таких как SQL-инъекции, XSS, CSRF.
9. Принципы SOLID
S: Single Responsibility Principle - Принцип единственной ответственности.
O: Open/Closed Principle - Принцип открытости/закрытости.
L: Liskov Substitution Principle - Принцип подстановки Лисков.
I: Interface Segregation Principle - Принцип разделения интерфейсов.
D: Dependency Inversion Principle - Принцип инверсии зависимостей.
10. Основы работы с коллекциями
Основные интерфейсы: List, Set, Map, их реализации и когда использовать каждую из них.
Потокобезопасные коллекции: Знание о коллекциях из пакета java.util.concurrent, таких как ConcurrentHashMap и CopyOnWriteArrayList.

* * *

## Master Microservices with SpringBoot,Docker,Kubernetes
├── Основы микросервисов и их архитектура  
│ └── Сравнение Monolithic, SOA и Microservices архитектуры  
│ └── Определение микросервисов  
│ └── Основы построения микросервисов  
│ └── Принципы выделения границ микросервисов и их размера  
│ └── Введение в SpringBoot  
│ └── Создание микросервисов на базе SpringBoot  
│ └── Hello World REST API с @RestController  
│ └── Работа с DTO (Data Transfer Object)  
├── Работа с данными в микросервисах  
│ └── Конфигурация H2 DB и YAML свойств  
│ └── Spring Data JPA для взаимодействия с таблицами БД  
│ └── CRUD операции в микросервисах  
│ └── CREATE API  
│ └── READ API  
│ └── UPDATE API  
│ └── DELETE API  
│ └── Обработка исключений на глобальном уровне  
│ └── Работа с аудиторскими колонками в базах данных  
├── Документирование микросервисов  
│ └── Введение в springdoc openapi  
│ └── Документирование REST API с использованием @OpenAPIDefinition, @Tag, @Operation, @ApiResponse, @Schema  
├── Деплой и работа с контейнерами  
│ └── Введение в контейнеры и Docker  
│ └── Генерация Docker образов для микросервисов  
│ └── Работа с Docker Compose для развертывания микросервисов 
│ └── Управление конфигурацией через Spring Cloud Config и Docker Compose  
│ └── Оркестрация контейнеров с использованием Kubernetes  
│ └── Создание и развертывание Helm Charts для микросервисов  
├── Взаимодействие и сервисная коммуникация  
│ └── Введение в Service Discovery и регистрацию сервисов 
│ └── Работа с Eureka Server  
│ └── Feign Client для межсервисного взаимодействия  
│ └── Введение в API Gateway (Spring Cloud Gateway)  
│ └── Настройка роутинга и фильтров  
│ └── Реализация межсервисного трейсинга и логирования  
│ └── Проблемы внешней коммуникации и Resiliency  
│ └── Паттерн Circuit Breaker (в API Gateway и Feign Client)  
│ └── Паттерн Retry  
│ └── Паттерн Rate Limiting (Redis RateLimiter)  
│ └── Паттерн Bulkhead  
│ └── Демонстрация паттернов Resiliency в Docker  
├── Наблюдаемость и мониторинг микросервисов  
│ └── Введение в Observability и Monitoring  
│ └── Централизованное логирование с Grafana, Loki, Promtail  
│ └── Сбор и отображение метрик с Actuator, Micrometer, Prometheus и Grafana  
│ └── Distributed Tracing с OpenTelemetry, Tempo и Grafana  
├── Безопасность микросервисов  │ └── Введение в OAuth2 и OpenID Connect  
│ └── Настройка авторизации и аутентификации с KeyCloak  
│ └── Безопасность Gateway сервера с OAuth2  
├── Event-driven микросервисы  
│ └── Введение в Event-driven модели  
│ └── Spring Cloud Function и Spring Cloud Stream  
│ └── Асинхронная коммуникация с RabbitMQ и Kafka  
│ └── Демонстрация работы с событиями через Docker и Kubernetes  

* * *

SOAP Request Structure  
├── SOAP Envelope - Основной контейнер для SOAP-сообщения, который определяет, что сообщение является SOAP-сообщением.  
│ ├── xmlns:soap - Пространство имен, указывающее, что это SOAP-сообщение.  
│ └── Пример: <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">  
│  
├── SOAP Header (необязательный) - Содержит метаданные о сообщении, такие как аутентификация или информация о маршрутизации.  
│ └── Пример:  
│ [soap:Header](soap:Header)  
│ <m:AuthHeader xmlns:m="http://example.com/">  
│ &lt;m:Username&gt;user&lt;/m:Username&gt;  
│ &lt;m:Password&gt;pass&lt;/m:Password&gt;  
│ &lt;/m:AuthHeader&gt;  
│ &lt;/soap:Header&gt;  
│  
└── SOAP Body - Основная часть сообщения, содержащая данные запроса и параметры, необходимые для выполнения операции.  
└── Пример:  
[soap:Body](soap:Body)  
<m:GetUser xmlns:m="http://example.com/">  
&lt;m:userId&gt;123&lt;/m:userId&gt;  
&lt;/m:GetUser&gt;  
&lt;/soap:Body&gt;

* * *

* * *

Кучи нужны для реализации особого типа сортировки, называемого, как ни странно, “сортировка кучей”. В отличие от менее эффективных “сортировки вставками” и “сортировки пузырьком”, с их ужасной сложностью в O(n2), “сортировка кучей” имеет сложность O(nlogn).

Реализация до неприличия проста. Просто продолжайте последовательно извлекать из кучи максимальный (корневой) элемент, и записывайте его в массив, пока куча не опустеет.

* * *
придумай вопрос с подвохом типа такого. Почему индекс построен на Btree если Хеш имеет сложность всего о(1) вместо о(логН)
* * *


> слушай а можешь придумать мне список вопросов для собеса на midl java разработчик. Только вопросы не на знание а на понимание. когда знание фактов без понимания принципа не помогут
1. Объясните, как работает механизм сборки мусора в Java. Какие преимущества и недостатки он имеет?
2. Расскажите о принципах SOLID. Как они помогают в разработке?
3. Что такое DI (Dependency Injection)? Почему он важен и как его реализовать?
4. Объясните, как работает механизм синхронизации в Java. Когда и почему он необходим?
5. Расскажите о паттернах проектирования. Приведите примеры и объясните, когда их применять.
6. Что такое функциональное программирование? Как оно реализовано в Java 8+?
7. Объясните принцип работы сетевых протоколов HTTP и TCP/IP. Как они взаимодействуют?
8. Расскажите о принципах тестирования. Какие виды тестов вы используете и как их интегрировать в CI/CD?
9. Объясните, как работает JVM. Что такое bytecode и как он выполняется?
10. Расскажите о принципах масштабирования приложений. Какие подходы и инструменты вы используете?
11. Объясните, как работает механизм кэширования. Какие виды кэширования вы применяли?
12. Расскажите о принципах безопасности приложений. Какие меры вы предпринимаете для защиты от уязвимостей?
13. Объясните, как работает механизм логирования. Какие фреймворки и подходы вы используете?
14. Расскажите о принципах работы с базами данных. Как вы оптимизируете запросы и схему данных?
15. Объясните, как работает механизм аутентификации и авторизации. Какие подходы вы применяли?
* * *
> "Первый = Индексы в БД ускоряют доступ к подготовленным данным, но минусы это замедление процедур добавления данных в БД и проблема что бы кеширование не дублировало функционал индексов а то все плюсы индексов выполнят кеши а минусы останутся. Второй = индекс Btree имеет сложность логН, а если применять Хеш индекс то сложность О(1) тогда зачем по умолчанию Btree?"
> 
