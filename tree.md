корень  
▒▒▒▒/☂\\☂\\_ вариант 1  
▒▒▒/☂☂\\_ вариант 2  
▒▒/☂\\_ вариант 3  
▒/_ вариант 4

* * *

Transaction Isolation Levels  
├── READ_UNCOMMITTED - Чтение незафиксированных  
│   данных (грязные чтения возможны)  
│  
├── READ_COMMITTED - Чтение только  
│   зафиксированных данных (предотвращает 
│   грязные чтения), но остаются  
│   неповторяемые чтения имеющихся строк  
│  
├── REPEATABLE_READ - Повторяемое чтение  
│   (предотвращает грязные и  
│   неповторяемые чтения), но  
│   "фантомное чтение новых строк"  
│   **+ в PostgreSQL также защищена  
│   от фантомного чтения через снимки**  
│  
└── SERIALIZABLE - Сериализуемый уровень  
    (самый строгий, предотвращает все  
    аномалии) 

* * *

CompletableFuture Methods  
├── get() - Блокирующий, возвращает  
│   результат  
│  
├── join() - Блокирующий, возвращает  
│   результат или выбрасывает  
│   исключение  
│  
├── complete(T) - Завершает бин с  
│   указанным значением  
│  
├── completeExceptionally(Throwable) -  
│   Завершает бин с исключением  
│  
├── whenComplete(BiConsumer) -  
│   Обрабатывает завершение,  
│   независимо от результата  
│  
├── exceptionally(Function) -  
│   Обрабатывает исключение и  
│   возвращает значение  
│  
├── handle(BiFunction) -  
│   Обрабатывает результат или  
│   исключение  
│  
├── thenApply(Function) -  
│   Применяет функцию к результату  
│  
├── thenAccept(Consumer) -  
│   Выполняет действие с результатом  
│  
└── thenRun(Runnable) -  
    Выполняет действие после  
    завершения  


* * *

Bean Scopes  
├── Singleton - Один экземпляр бина на весь контейнер  
├── Prototype - Новый экземпляр создается при каждом запросе  
├── Request - Экземпляр бина для каждого HTTP-запроса  
├── Session - Экземпляр бина для каждой HTTP-сессии  
└── Global Session - Экземпляр бина для глобальной HTTP-сессии (для портлетов)

* * *

Bean Annotations  
├── @Component - Общая аннотация для определения бина  
├── @Service - Специальная аннотация для сервисных компонентов  
├── @Repository - Аннотация для DAO-компонентов, обрабатывающих исключения  
├── @Controller - Аннотация для контроллеров в веб-приложениях  
├── @Configuration - Аннотация для классов, содержащих конфигурацию бинов  
└── @Bean - Аннотация для определения метода, возвращающего бин

* * *

Transaction Annotations  
├── @Transactional - Обозначает метод или класс как транзакционный  
├── @EnableTransactionManagement - Включает поддержку управления транзакциями в конфигурации  
└── @Transactional(propagation = Propagation) - Указывает тип поведения транзакции (например, REQUIRED, REQUIRES_NEW)


Transaction Annotations  
├── @Transactional - Обозначает метод или  
│   класс как транзакционный. Это  
│   значит, что все операции внутри  
│   этого метода будут выполняться в  
│   рамках одной транзакции.  
│    └── @Transactional(propagation =  
│        |   Propagation) - Указывает тип  
│        |   поведения транзакции.  
│        ├── Propagation.REQUIRED - Если  
│        |   существует активная транзакция,  
│        |   метод будет участвовать в ней.  
│        |   Если транзакции нет, будет  
│        |   создана новая. Это наиболее  
│        |   часто используемый режим.  
...
* * *

Transaction Annotations  
├── @Transactional - Обозначает метод или класс как транзакционный. Это значит, что все операции внутри этого метода будут выполняться в рамках одной транзакции.  
│ └── @Transactional(propagation = Propagation) - Указывает тип поведения транзакции.  
│ ├── Propagation.REQUIRED - Если существует активная транзакция, метод будет участвовать в ней. Если транзакции нет, будет создана новая. Это наиболее часто используемый режим.  
│ ├── Propagation.REQUIRES_NEW - Всегда создает новую транзакцию. Если текущая транзакция существует, она будет приостановлена до завершения новой транзакции.  
│ ├── Propagation.SUPPORTS - Участвует в транзакции, если она активна. Если транзакции нет, метод будет выполнен без транзакции.  
│ ├── Propagation.NOT_SUPPORTED - Метод не участвует в транзакциях. Если существует активная транзакция, она будет приостановлена.  
│ ├── Propagation.NEVER - Метод не должен участвовать в транзакциях. Если активная транзакция существует, будет выброшено исключение.  
│ ├── Propagation.MANDATORY - Метод должен участвовать в существующей транзакции. Если транзакции нет, будет выброшено исключение.  
│ └── Propagation.NESTED - Позволяет создавать вложенные транзакции. Если существует активная транзакция, будет создана новая вложенная транзакция. Если вложенная транзакция завершится неудачно, изменения будут отменены, но основная транзакция продолжит свою работу.  
│  
├── @EnableTransactionManagement - Включает поддержку управления транзакциями в конфигурации приложения.  
│ └── mode = AdviceMode.PROXY - Использует режим проксирования для управления транзакциями, позволяя создавать прокси-объекты для методов с аннотацией @Transactional.  
│ └── mode = AdviceMode.ASPECTJ - Использует режим AspectJ для управления транзакциями, позволяя более гибкое управление аспектами без создания прокси.  
│  
├── @Transactional(isolation = Isolation) - Указывает уровень изоляции транзакции, который определяет, как изменения в одной транзакции видны другим транзакциям.  
│ ├── Isolation.DEFAULT - Использует настройки источника данных по умолчанию.  
│ ├── Isolation.READ_UNCOMMITTED - Позволяет чтение незафиксированных данных (грязные чтения возможны).  
│ ├── Isolation.READ_COMMITTED - Позволяет чтение только зафиксированных данных, предотвращая грязные чтения, но оставляя возможность неповторяемых чтений.  
│ ├── Isolation.REPEATABLE_READ - Предотвращает грязные и неповторяемые чтения, но может возникать "фантомное чтение" новых строк.  
│ └── Isolation.SERIALIZABLE - Самый строгий уровень изоляции, предотвращающий все аномалии, включая фантомные чтения.  
│  
└── @Transactional(timeout = seconds) - Указывает тайм-аут транзакции в секундах. Если транзакция не завершится в указанный срок, она будет автоматически отменена.

* * *

Java Collections  
├── Collection - Корневой интерфейс для всех коллекций  
│ ├── List - Упорядоченная коллекция, допускающая дубликаты  
│ │ ├── ArrayList - Реализация списка на основе массива  
│ │ ├── LinkedList - Реализация списка на основе связного списка  
│ │ └── Vector - Устаревшая реализация списка, синхронизированная  
│ ├── Set - Коллекция, не допускающая дубликаты  
│ │ ├── HashSet - Реализация множества на основе хеш-таблицы  
│ │ ├── LinkedHashSet - Хранит порядок вставки элементов  
│ │ └── TreeSet - Реализация множества, хранящая элементы в отсортированном порядке  
│ └── Queue - Коллекция для хранения элементов в порядке их обработки  
│ ├── PriorityQueue - Очередь, упорядоченная по приоритету  
│ └── LinkedList - Может использоваться как очередь  
└── Map - Коллекция пар "ключ-значение"  
├── HashMap - Реализация карты на основе хеш-таблицы  
├── LinkedHashMap - Хранит порядок вставки ключей  
└── TreeMap - Реализация карты, хранящая ключи в отсортированном порядке

* * *

Concurrent Collections  
├── java.util.concurrent - Пакет для потокобезопасных коллекций  
│ ├── ConcurrentHashMap - реализация интерфейса Map  
│ ├── CopyOnWriteArrayList - Создает копии при изменениях  
│ ├── BlockingQueue - Интерфейс для очередей с блокировкой  
│ │ ├── LinkedBlockingQueue - Реализация на основе связного списка  
│ │ ├── ArrayBlockingQueue - Ограниченная очередь на основе массива  
│ │ └── PriorityBlockingQueue - С приоритетом  
│ ├── ConcurrentLinkedQueue - Неблокирующая очередь  
│ ├── ConcurrentSkipListMap - отсортированная карта  
│ └── ConcurrentSkipListSet - отсортированное множество

* * *

Design Patterns  
├── Creational Patterns  
│ ├── Singleton - Обеспечивает создание единственного экземпляра класса  
│ ├── Factory Method - Определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемого объекта  
│ ├── Abstract Factory - Интерфейс для создания семейств связанных объектов без указания их конкретных классов  
│ ├── Builder - Позволяет создавать сложные объекты пошагово  
│ └── Prototype - Создает новые объекты путем копирования существующих  
│  
├── Structural Patterns  
│ ├── Adapter - Позволяет несовместимым интерфейсам работать вместе  
│ ├── Bridge - Разделяет абстракцию и реализацию, позволяя изменять их независимо  
│ ├── Composite - Позволяет объединять объекты в древовидные структуры для представления иерархий  
│ ├── Decorator - Добавляет новые функциональные возможности к объектам динамически  
│ ├── Facade - Предоставляет упрощенный интерфейс к сложной системе  
│ ├── Flyweight - Оптимизирует использование памяти, разделяя общие состояния объектов  
│ └── Proxy - Предоставляет суррогат или заместитель для другого объекта для контроля доступа  
│  
└── Behavioral Patterns  
├── Chain of Responsibility - Позволяет передавать запросы по цепочке обработчиков  
├── Command - Инкапсулирует запрос как объект, позволяя параметризовать клиентов  
├── Interpreter - Определяет грамматику и интерпретирует предложения в языке  
├── Iterator - Предоставляет способ последовательного доступа к элементам коллекции  
├── Mediator - Обеспечивает взаимодействие между объектами, уменьшая их связанность  
├── Memento - Позволяет сохранять и восстанавливать состояние объекта  
├── Observer - Определяет зависимость "один ко многим" между объектами  
├── State - Позволяет объекту изменять свое поведение при изменении его состояния  
├── Strategy - Определяет семейство алгоритмов и делает их взаимозаменяемыми  
└── Template Method - Определяет основу алгоритма, позволяя подклассам изменять некоторые шаги

* * *

Stream API  
├── Создание потоков  
│ ├── Stream.of() - Создание потока из заданных значений.  
│ ├── Collection.stream() - Создание потока из коллекции.  
│ ├── Arrays.stream() - Создание потока из массива.  
│ └── Stream.generate() - Создание бесконечного потока значений на основе заданного генератора.  
│  
├── Промежуточные операции  
│ ├── filter() - Фильтрация элементов по заданному предикату.  
│ ├── map() - Преобразование элементов потока с помощью заданной функции.  
│ ├── flatMap() - Преобразование элементов потока, возвращающих другие потоки, и объединение их в один поток.  
│ ├── distinct() - Удаление дубликатов из потока.  
│ ├── sorted() - Сортировка элементов потока.  
│ └── peek() - Применение функции к каждому элементу потока без изменения потока.  
│  
├── Заключительные операции  
│ ├── forEach() - Применение действия к каждому элементу потока.  
│ ├── collect() - Сбор элементов потока в коллекцию или другую структуру данных.  
│ │ ├── Collectors.toList() - Преобразование потока в список.  
│ │ ├── Collectors.toSet() - Преобразование потока в множество.  
│ │ ├── Collectors.toMap() - Преобразование потока в карту (Map).  
│ │ └── Collectors.joining() - Объединение элементов потока в строку.  
│ ├── reduce() - Сведение элементов потока к одному значению с помощью заданной бинарной операции.  
│ ├── count() - Подсчет количества элементов в потоке.  
│ └── findFirst() - Получение первого элемента потока.  
│  
├── Параллельные потоки  
│ ├── parallelStream() - Создание параллельного потока из коллекции.  
│ ├── parallel() - Преобразование последовательного потока в параллельный.  
│ └── sequential() - Преобразование параллельного потока в последовательный.  
│  
└── Обработка исключений  
├── try-catch в промежуточных операциях - Обработка исключений во время обработки элементов.  
└── onError() - Обработка ошибок в потоках (в контексте реактивного программирования).

* * *

Блокировки  
├── Пессимистичные блокировки  
│ ├── Блокировка на чтение (Shared Lock)  
│ │ ├── Предотвращает запись других транзакций  
│ │ └── Разрешает чтение другими транзакциями  
│ │ ├── Используется в БД  
│ │ │ ├── SELECT ... FOR SHARE  
│ │ │ └── SELECT ... FOR UPDATE  
│ │ └── Используется в приложениях редко  
│ └── Блокировка на запись (Exclusive Lock)  
│ ├── Предотвращает чтение и запись других транзакций  
│ └── Разрешает чтение и запись только владельцу блокировки  
│ ├── Используется в БД  
│ │ └── UPDATE, DELETE, INSERT  
│ └── Используется в приложениях редко  
│  
└── Оптимистичные блокировки  
├── Версионирование (Optimistic Locking)  
│ ├── Каждая запись имеет версию  
│ ├── При обновлении проверяется версия  
│ └── Если версия изменилась, обновление отклоняется  
│ ├── Используется в БД редко  
│ └── Используется в приложениях  
│ ├── @Version в JPA  
│ └── optimisticLock в Spring Data  
└── Временные метки (Timestamp Locking)  
├── Каждая запись имеет временную метку  
├── При обновлении проверяется временная метка  
└── Если метка изменилась, обновление отклоняется  
├── Используется в БД редко  
└── Используется в приложениях  
└── optimisticLock в Spring Data

* * *

Блокировки в Spring и JDBC  
├── Пессимистичные блокировки  
│ ├── В JDBC  
│ │ ├── SELECT ... FOR UPDATE  
│ │ └── SELECT ... FOR SHARE  
│ └── В Spring  
│ ├── @Lock(LockModeType.PESSIMISTIC_WRITE) в JPA  
│ └── @Lock(LockModeType.PESSIMISTIC_READ) в JPA  
│  
└── Оптимистичные блокировки  
├── В JDBC  
│ ├── Версионирование  
│ │ ├── Добавление версионной колонки в таблицу  
│ │ └── Проверка версии при обновлении  
│ └── Временные метки  
│ ├── Добавление колонки с временной меткой в таблицу  
│ └── Проверка метки при обновлении  
└── В Spring  
├── @Version в JPA  
├── @Lock(LockModeType.OPTIMISTIC) в JPA  
├── @Lock(LockModeType.OPTIMISTIC_FORCE_INCREMENT) в JPA  
└── optimisticLock() в Spring Data

* * *

Locking Strategies  
├── Optimistic Locking - Предполагает редкие конфликты, блокировки не накладываются до сохранения изменений.  
│ ├── Применение: Используется в сценариях с высокой степенью параллелизма.  
│ ├── Реализация: Проверка версии данных перед записью (например, с помощью аннотации @Version в JPA).  
│ └── Результат: Если данные были изменены другой транзакцией, операция завершится с ошибкой, и транзакцию можно повторить.  
│  
└── Pessimistic Locking - Предполагает частые конфликты, блокировки накладываются сразу при доступе к данным.  
├── Применение: Используется в сценариях с высокой вероятностью конфликтов.  
├── Реализация: Блокировка удерживается до завершения транзакции (например, с помощью @Lock в JPA).  
└── Результат: Гарантирует эксклюзивный доступ к данным, предотвращая изменения другими транзакциями.

* * *

HTTP Request Structure  
├── Start Line - Стартовая строка запроса, содержащая три основных компонента:  
│ ├── Method - Метод HTTP (например, GET, POST, PUT, DELETE), указывающий действие, которое необходимо выполнить.  
│ ├── Request-URI - URI ресурса, к которому осуществляется запрос (например, /api/users).  
│ └── HTTP Version - Версия протокола HTTP (например, HTTP/1.1).  
│  
├── Headers - Заголовки запроса, содержащие метаданные о запросе:  
│ ├── Host - Указывает домен сервера, к которому осуществляется запрос.  
│ ├── User-Agent - Идентифицирует клиентское приложение (браузер) и его версию.  
│ ├── Accept - Определяет типы медиа, которые клиент может принимать (например, application/json).  
│ ├── Content-Type - Указывает тип содержимого в теле запроса (например, application/json).  
│ └── Другие заголовки, которые могут быть специфичными для приложения или протокола.  
│  
├── Blank Line - Пустая строка, отделяющая заголовки от тела запроса.  
│  
└── Body - Тело запроса (необязательная часть), содержащее данные, которые отправляются на сервер (например, JSON-объект при POST-запросе).

* * *

POST /api/users HTTP/1.1  
Host: example.com  
Content-Type: application/json  
Accept: application/json

{  
"name": "John Doe",  
"email": "john.doe@example.com"  
}

* * *
Microservices Architecture  
├── Service Discovery - Механизм для обнаружения и взаимодействия между микросервисами.  
│  
├── API Gateway - Упрощает взаимодействие клиентов с микросервисами, обеспечивая единый входной  
│   пункт для запросов.  
│  
├── Load Balancing - Распределяет входящие запросы между экземплярами микросервисов для  
│   повышения доступности и производительности.  
│  
├── Circuit Breaker - Защищает систему от сбоя, предотвращая повторные запросы к неработающим  
│   сервисам.  
│  
├── Database per Service - Каждый микросервис имеет свою собственную базу данных, что  
│   обеспечивает независимость и изоляцию данных.  
│  
├── Event Sourcing - Хранит состояние приложения как последовательность событий, что позволяет  
│   восстанавливать состояние системы.  
│  
├── CQRS (Command Query Responsibility Segregation) - Разделяет операции чтения и записи для  
│   оптимизации производительности и масштабируемости.  
│  
└── Monitoring and Logging - Системы для отслеживания состояния микросервисов и анализа логов  
    для диагностики и устранения проблем.  

* * *
Multithreading Concepts  
├── Threads - Основные единицы выполнения в Java.  
│   ├── Thread Class - Класс для создания и управления потоками.  
│   ├── Runnable Interface - Интерфейс для определения задачи, выполняемой в потоке.  
│   └── Thread Lifecycle - Жизненный цикл потока:  
│       ├── New - Новый поток.  
│       ├── Runnable - Поток готов к выполнению.  
│       ├── Blocked - Поток заблокирован.  
│       ├── Waiting - Поток ожидает.  
│       └── Terminated - Поток завершен.  
│  
├── Synchronization - Механизмы синхронизации для управления доступом к ресурсам.  
│   ├── Synchronized Blocks - Блоки кода, защищенные синхронизацией.  
│   ├── Locks - Более гибкие механизмы синхронизации.  
│   │   ├── ReentrantLock - Мьютекс, поддерживающий повторный захват.  
│   │   └── ReadWriteLock - Позволяет нескольким потокам читать, но блокирует запись.  
│   ├── Volatile Variables - Переменные, доступ к которым не кэшируется, обеспечивая видимость изменений.  
│   └── Atomic Variables - Переменные, которые обеспечивают атомарные операции.  
│  
├── Semaphores - Механизм синхронизации для управления доступом к ресурсам.  
│   ├── Definition - Семафор как счетчик, контролирующий количество потоков, имеющих доступ.  
│   ├── Counting Semaphore - Позволяет нескольким потокам одновременно получать доступ к ресурсу.  
│   └── Binary Semaphore - Позволяет только одному потоку получить доступ к ресурсу.  
│  
├── Condition Variables - Позволяют потокам ожидать определенных условий.  
│   ├── await() - Ожидание сигнала.  
│   └── signal() - Уведомление ожидающих потоков.  
│  
└── Thread Pools - Группы потоков для управления многопоточными задачами.  
    ├── Executor Framework - Интерфейс для управления потоками.  
    ├── Fixed Thread Pool - Фиксированное количество потоков.  
    └── Cached Thread Pool - Динамическое создание потоков по мере необходимости.  

* * *
Happens-Before Principle  
├── Definition - Определение порядка  
│   выполнения операций в многопоточном  
│   окружении.  
│  
├── Transitive Property -  
│   Если A happens-before B, и B  
│   happens-before C, то A  
│   happens-before C.  
│  
├── Program Order Rule -  
│   Каждая операция в одном потоке  
│   происходит в порядке, в котором  
│   они были написаны.  
│  
├── Monitor Lock Rule -  
│   Захват монитора (синхронизация)  
│   потоком A делает все операции  
│   этого потока видимыми для других  
│   потоков, которые захватывают тот  
│   же монитор.  
│  
├── Volatile Variable Rule -  
│   Запись в переменную с  
│   модификатором `volatile`  
│   происходит до всех последующих  
│   чтений этой переменной.  
│  
└── Thread Start/Join Rule -  
    Запуск потока (start)  
    происходит до завершения  
    потока (join).  
* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *
* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *

* * *
SOAP Request Structure  
├── SOAP Envelope - Основной контейнер для SOAP-сообщения, который определяет, что сообщение является SOAP-сообщением.  
│ ├── xmlns:soap - Пространство имен, указывающее, что это SOAP-сообщение.  
│ └── Пример: <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">  
│  
├── SOAP Header (необязательный) - Содержит метаданные о сообщении, такие как аутентификация или информация о маршрутизации.  
│ └── Пример:  
│ [soap:Header](soap:Header)  
│ <m:AuthHeader xmlns:m="http://example.com/">  
│ &lt;m:Username&gt;user&lt;/m:Username&gt;  
│ &lt;m:Password&gt;pass&lt;/m:Password&gt;  
│ &lt;/m:AuthHeader&gt;  
│ &lt;/soap:Header&gt;  
│  
└── SOAP Body - Основная часть сообщения, содержащая данные запроса и параметры, необходимые для выполнения операции.  
└── Пример:  
[soap:Body](soap:Body)  
<m:GetUser xmlns:m="http://example.com/">  
&lt;m:userId&gt;123&lt;/m:userId&gt;  
&lt;/m:GetUser&gt;  
&lt;/soap:Body&gt;

* * *

* * *
Кучи нужны для реализации особого типа сортировки, называемого, как ни странно, “сортировка кучей”. В отличие от менее эффективных “сортировки вставками” и “сортировки пузырьком”, с их ужасной сложностью в O(n2), “сортировка кучей” имеет сложность O(nlogn).

Реализация до неприличия проста. Просто продолжайте последовательно извлекать из кучи максимальный (корневой) элемент, и записывайте его в массив, пока куча не опустеет.
* * *
